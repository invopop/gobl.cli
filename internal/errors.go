package internal

import (
	"fmt"

	"github.com/invopop/gobl"
)

// Status codes used in the CLI that map to HTTP status codes
const (
	StatusBadRequest          int = 400
	StatusConflict            int = 409
	StatusUnprocessableEntity int = 422
)

// Error wraps around around any messages generated by the cli and attempts
// to provide a structured output that can be interpreted.
type Error struct {
	Code    int    `json:"code"`            // HTTP status code
	Key     string `json:"key,omitempty"`   // For GOBL errors
	Cause   error  `json:"cause,omitempty"` // Structured error message
	Message string `json:"message,omitempty"`
}

// Error provides a string representation of the error. This should only really
// be used for testing purposes.
func (e *Error) Error() string {
	if e == nil {
		return ""
	}
	msg := e.Message
	if msg == "" && e.Cause != nil {
		msg = e.Cause.Error()
	}
	if msg == "" {
		msg = e.Key
	}
	if msg == "" {
		msg = "unknown-error"
	}
	return fmt.Sprintf("code=%d, message=%s", e.Code, msg)
}

// wrapError is used to ensure that we always provide a structured response
func wrapError(code int, err error) *Error {
	if e, ok := err.(*Error); ok {
		return e
	}
	out := new(Error)
	out.Code = code
	switch e := err.(type) {
	case *gobl.Error:
		out.Key = e.Key.String()
		out.Cause = e.Cause
	default:
		out.Message = e.Error()
	}
	return out
}

// wrapErrorf makes it easier to wrap around errors that need extra data.
func wrapErrorf(code int, format string, args ...any) *Error {
	return wrapError(code, fmt.Errorf(format, args...))
}
